# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree

# Ensure correct AST creation given units defined under: https://docs.python.org/3/library/ast.html :: 3.10.7 grammar
# Note: the guide referenced above is not complete, so we've extended it here wher appropriate


## Constant(value)
123123
123.4124
'a string'

## FormattedValue(value, conversion, format_spec)
f"sin({a}) is {sin(a):.3}"

## JoinedStr(values)
f"sin({a}) is {sin(a):.3}"

## List(elts, ctx)
[1, 2, 3]

## List assign
# [a,b] = 2, 3

## Tuple(elts, ctx)
(1, 2, 3)

## single element tuple
thing = 1,
thing = (1,)

## expression statement postfixed with comma
# The following is treated as a tuple due to the trailing comma
Union[
            str,
            int
        ],

## Set(elts)
{1, 2, 3}

## Dict(keys, values)
{'a':1, 'd':5}

## Dict with dictionary_splat
f = {**arg1, **arg2}

## Dict with dictionary_splat and normal keys
f = {**arg1, 'a': 55}

## strings with nested ' or "

x='bb "a" cc'
y="bb 'a' cc"

## string variants
a='a string'
b="a string" # should be converted to 'a string'

## more tricky string variants
x='bb "a" cc'
y="bb 'a' cc"

y="bb \"a\" cc" # should be converted to 'bb "a" cc'
y="bb \'a\' cc" # \ should be removed
z = "\n"

## complex string variants with multiline

x='''bb "a" cc'''
y="""bb 'a' cc"""

a = 'baaa'
b = "baaa"
c = '''baaa'''
d = """baaa"""
multiline = '''
asdas

asdads

    pass

'''

multiline2 = """
asdas

asdads

    pass

"""

## Ellipsis
...

## None
None


## fstring which behave like normal strings
f'nothing'
f"nothing"

f'nothing "thing" '
f"nothing 'thing' "

## f string simple cases
f"sin({a+b}) is {sin(a):.3}"
f'sin({a+b}) is {sin(a):.3}'

## f string simple cases with initial offset
m = f"something{sin(a)} "
m = f"something"

## f string simple cases
f"sin({a+b}) i's {sin(a):.3}"
f'sin({a+b}) i"s {sin(a):.3}'

## f string simple cases w remainder at end
f"sin({a+b}) is {sin(a):.3} plus remainder"
f'sin({a+b}) is {sin(a):.3} plus remainder'

f"Magic wand: {bag['wand']:^10}"
f'Magic wand: {bag["wand"]:^10}'

## f string these f strings require special quote treatment
f"{a['b']}"
f'{a["b"]}'

f"a '' {b} c"
f'a "" {b} c'
f"a  {b} c"
f'a  {b} c'

## f string more examples
f'He said his name is {name!r}.'
f"sin({a}) is {sin(a):.3}" # nothing after final }
f'Results of the {year} {event}'
f"{a} is {sin(a):.3}" # at start

## f strings - nested
f" f'hi' "
f" {f'hi'} "

## f strings - multi-line
f"""sin({a}) is {sin(a):.3} plus remainder {also} something else {here}"""
f"""sin({a}) is {sin(a):.3} plus remainder {also} something else {here} """
f"""sin({a}) is {sin(a):.3} plus remainder {also} something else {here} remainder"""

f"""is plus remainder something else something else """

f"""is
 plus remainder
 something else
 something else"""

f"""is
 plus remainder
 something else
 something else """

## potential CPython bug here,
# column offsets for interpolation nodes for
# nodes on the nth (where n>0) line are off by one
f'''{sin(a+b)} is
    {cos(b+c):.3} plus remainder
    {tan(a):.3} plus remainder'''


f"""sin({a}) is
{ccos(a):.3} plus remainder
something else {here}
something
else {here}
{also
} something else {here}"""

f"""sin({a}) is
 {sin(a):.3} plus remainder
 something else {here}
 something
 else {here}
 {also
 } something else {here}"""

## string concatinated - regular strings

message = "something " \
          "another {a} line"

message = "something " \
          "another ' line" # stored with double quote " in ast

message = 'something ' \
          'another {a} line'

message = 'something ' \
          'another \' line' # stored with double quote " in ast


## string concatinated - f strings
message = f"something " \
          f"another ' {a} line"

message = f"something{sin(a)} " \
          f"another {a} line" \
          f"another line" \
          "another line with no f string" \


message = "something " \
          f"another {a} line"

message = "something " \
          f"another ' {a} line"


## f-string concatinated

message = f"Hi {name}. " \
          f"You are a {profession}. " \
          f"You were in {affiliation}."

## f-string concatinated tricky cases with {} escape formatting

message = f"something " \
          "another {{a}} line"

message = f"something " \
          "another {a} line"

## f-string {{}} escape formatting
"{{{a}}}"
f"{{{{55}}}}"
f"{{55}}"
f"{k} {{55}}"
f"{{{55}}}"
f"{{{{70 + 4}}}}"

## long integers
timestamp1 = 9223372036854775810
timestamp2 = -9223372036854775810

## complex numbers
complex_half = 0.0302988j

c = 1 + 2.j
c = 1 + 2j
c = 1 + 2.J
c = 1 + 2J
real = c.real
imag = c.imag

## very long floats
timestamp = 0.33333333333333334444444444444444356456456456456456457457456456456456456456
timestamp = 123123123.94856098745609847560987450968734986745096874509867405968740598674509867405968456

## long floats - big exponent
timestamp3 = 9223372036854775810.
timestamp4 = -9223372036854775810.

## long floats - scientific if exponent > 16 digits

not_scientific = 1111111111111111.
scientific = 11111111111111111.

not_scientific = -1111111111111111.
scientific = -11111111111111111.

## long floats - scientific if exponent > 16 digits with mantissa

not_scientific_mantissa = 1111111111111111.123
scientific_mantissa     = 11111111111111111.123

not_scientific_mantissa = -1111111111111111.123
scientific_mantissa     = -11111111111111111.123

## format complex numbers with exponent if more then 16 significant digits
c1 = 1 + 20000.j
c2 = 1 + 20000j
c3 = 1 + 20000.J
c4 = 1 + 20000J

c5 = 1 + 20000000000000000000000.j
c6 = 1 + 20000000000000000000000j
c7 = 1 + 20000000000000000000000.J
c8 = 1 + 20000000000000000000000J

## format complex numbers with exponent if more then 16 significant digits with mantissa
m1 = 1 + 2000000.123j
m2 = 1 + 2000000.123J

m3 = 1 + 2000000000000000000.123j
m4 = 1 + 2000000000000000000.123J

## ensure complex numbers which look like integers are correctly formatted
c6 = 1 + 2000000j
c8 = 1 + 2000000J

c6 = 1 + 2000000000000j
c8 = 1 + 2000000000000J

c6 = 1 + 200000000000000000000j
c8 = 1 + 200000000000000000000J

## b strings single and multiline variants
v1 = b'a b string'
v2 = b"a b string"

h = b"""asasd"""
h = b'''asasd'''

## regex strings single and multiline variants
v1 = r'a b string'
v2 = r"a b string"

h = r"""asasd"""
h = r'''asasd'''

## raw multiline strings
s = r"""a
b
c
"""
t = b"""a
b
c
"""

## strings with line continuations
a = """\
"""
b = '''\
'''
c = "\
"
d = '\
'

## raw strings with trailing slashes that shouldn't be treated as line continuations
a = r"""\
"""
b = r'''\
'''
c = r"\
"
d = r'\
'
h = r"""a\
b\
c
"""

## byte strings with line continuations
a = b"""\
"""
b = b'''\
'''
c = b"\
"
d = b'\
'
h = b"""a\
b\
c
"""

## strings wrapping ' and "
a = '"'
b = "'"

## b strings wrapping ' and "
a = b'"'
b = b"'"

## raw strings wrapping ' and "
a = r'"'
b = r"'"

## raw strings backslashes
a = r'\"'
b = r'\''

## small floating point numbers need scientific representation
p =  0.1
p =  0.01
p =  0.001
p =  0.0001
p =  0.00001
p =  0.000001
p =  0.0000001
p =  0.00000001
p =  0.000000001
p =  0.0000000001
p =  0.00000000001
p =  0.000000000001
p =  0.0000000000001
p =  0.00000000000001
m = -0.00000000000001
m = -0.0000000000001
m = -0.000000000001
m = -0.00000000001
m = -0.0000000001
m = -0.000000001
m = -0.00000001
m = -0.0000001
m = -0.000001
m = -0.00001
m = -0.0001
m = -0.001
m = -0.01
m = -0.1

## zero should not be shown in scientific format
xx = 0.0 # not to be shown in scientific format

## complex type annotation
# this was the source of a few bugs

SearchUnion = Union[
    List[
        Union[
            Dict[str, Union[List[FlowRunStatus], str]],
            Dict[str, Union[List[str], str]],
            Dict[str, str],
        ],
    ],
    str,
]
